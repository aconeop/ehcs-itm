# -*- coding: utf-8 -*-
"""DLHM_reconstruction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yim1g6ZujxaTz0zoE8wghl16rxMGgMhB
"""

# FUNCTION TO RECONSTRUCT AN IN LINE HOLOGRAM WITH THE METHODOLOGY FROM THE JÜRGEN KREUZER'S PATENT
import math
import numpy as np
import cv2
from PIL import Image
from os import listdir
from datetime import timedelta
import matplotlib.pyplot as plt
from timeit import default_timer as timer

def filtcosenoF(par,fi,co):
    # Coordenadas
    [xfc, yfc] = np.meshgrid(np.linspace(1-co/2, co/2, co), np.linspace(fi/2, 1-fi/2, fi))

    # Normalizar coordenadas en intervalo (-pi, pi) y crear filtros en dirección horizontal y vertical
    fc1 = np.cos(xfc*(math.pi/par)*(1/np.max(xfc)))**2
    fc2 = np.cos(yfc*(math.pi/par)*(1/np.max(yfc)))**2

    # Intersectar ambas direcciones
    fc = (fc1 > 0) * fc1 * (fc2 > 0) * fc2

    # Re-escalar de 0 a 1
    return fc / np.max(fc)

def prepairholoF(CH_m, dx, L):
    [row, col] = CH_m.shape
    Wx = dx * col
    Wy = dx * row

    # Matriz de coordenadas
    [X, Y] = np.meshgrid(range(col), range(row))

    # Coordenadas de origen del holograma
    xo = -Wx / 2
    yo = -Wy / 2

    # Holograma preparado, coordenadas de origen
    xop = xo * L / math.sqrt(L ** 2 + xo ** 2)
    yop = yo * L / math.sqrt(L ** 2 + yo ** 2)

    Xp = dx * (X - col/2) * L / np.sqrt(L**2 + (dx**2) * (X - col/2)**2 + (dx**2) * (Y - row/2)**2)
    Yp = dx * (Y - row/2) * L / np.sqrt(L**2 + (dx**2) * (X - col/2)**2 + (dx**2) * (Y - row/2)**2)

    # Coordenadas enteras más bajas
    iXcoord = np.floor((Xp - xop) / (-2 * xop / col)).astype(np.uint16)
    iYcoord = np.floor((Yp - yop) / (-2 * xop / row)).astype(np.uint16)

    # Calcular la fracción para la interpolación
    x1frac = (iXcoord + 1.0) - Xp
    x2frac = 1.0 - x1frac
    y1frac = (iYcoord + 1.0) - Yp
    y2frac = 1.0 - y1frac

    x1y1 = x1frac * y1frac
    x1y2 = x1frac * y2frac
    x2y1 = x2frac * y1frac
    x2y2 = x2frac * y2frac

    # Pre-asignar el holograma preparado
    CHp_m = np.zeros((row, col))

    # Preparar holograma (preparación1 - remapeo de cada píxel)
    for it in range(row-1):
        for jt in range(col-1):
            CHp_m[iYcoord[it, jt], iXcoord[it, jt]] += x1y1[it, jt] * CH_m[it, jt]
            CHp_m[iYcoord[it, jt], iXcoord[it, jt] + 1] += x2y1[it, jt] * CH_m[it, jt]
            CHp_m[iYcoord[it, jt] + 1, iXcoord[it, jt]] += x1y2[it, jt] * CH_m[it, jt]
            CHp_m[iYcoord[it, jt] + 1, iXcoord[it, jt] + 1] += x2y2[it, jt] * CH_m[it, jt]

    return CHp_m

def prepairholoF_remap(CH_m, dx, L):
    [row, col] = CH_m.shape
    Wx = dx * col
    Wy = dx * row

    # Matriz de coordenadas
    [X, Y] = np.meshgrid(range(col), range(row))
    X = X - col / 2
    Y = Y - row / 2

    r = np.sqrt(X**2 + Y**2)
    rW = np.sqrt((Wx/2)**2 + (Wy/2)**2)
    auxL = np.max(r) * L / np.max(rW)
    theta = np.arctan2(Y, X)
    R = auxL * np.sin(r / auxL)

    Xcoord = R * np.cos(theta)
    Ycoord = R * np.sin(theta)
    Xcoord = (Xcoord + col / 2).astype(np.float32)
    Ycoord = (Ycoord + row / 2).astype(np.float32)
    CHp_m = cv2.remap(CH_m, Xcoord, Ycoord, cv2.INTER_AREA, borderMode=cv2.BORDER_CONSTANT, borderValue=0)

    return CHp_m

def kreuzer3F(CHp_m, z, L, lamb, deltaX, FC):
    [row, col] = CHp_m.shape
    Wx = dx * col
    Wy = dx * row

    # Coordenadas de origen del holograma
    xo = -Wx / 2
    yo = -Wy / 2

    # Holograma preparado, coordenadas de origen
    xop = xo * L / math.sqrt(L ** 2 + xo ** 2)
    yop = yo * L / math.sqrt(L ** 2 + yo ** 2)

    # Pixel cuadrado:
    deltaY = deltaX

    # Matriz tamaño
    [X, Y] = np.meshgrid(range(col), range(row))
    X = X.astype(np.float64)
    Y = Y.astype(np.float64)

    # Tamaño del píxel para el holograma preparado
    deltaxp = xop / (-col / 2)
    deltayp = yop / (-row / 2)

    # Coordenadas de origen para el plano de reconstrucción
    Yo = -deltaX * (row / 2)
    Xo = -deltaX * (col / 2)

    # Convertir CHp_m a complex128 si no lo es
    if CHp_m.dtype != np.complex128:
        CHp_m = CHp_m.astype(np.complex128)

    # Multiplicar holograma preparado con fase de propagación
    Rp = np.sqrt((L**2) - (deltaxp * X + xop)**2 - (deltayp * Y + yop)**2)
    r = np.sqrt((deltaX**2) * ((X - col / 2)**2 + (Y - row / 2)**2) + z**2)
    CHp_m *= ((L / Rp)**4) * np.exp(-0.5j * (2 * math.pi / lamb) * (r**2 - 2 * z * L) * Rp / (L**2))

    # Valor de relleno constante
    pad = int(col / 2)

    # Relleno en la fila del coseno
    FC = np.pad(FC, pad)

    # Operación de convolución
    # Primer transformar
    T1 = CHp_m * np.exp((1j * (2 * math.pi / lamb) / (2 * L)) * (2 * Xo * X * deltaxp + 2 * Yo * Y * deltayp + X**2 * deltaxp * deltaX + Y**2 * deltayp * deltaY))
    T1 = np.pad(T1, pad)
    T1 = np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(T1 * FC)))

    # Segundo transformar
    T2 = np.exp(-1j * (2 * math.pi / lamb) / (2 * L) * ((X - col / 2)**2 * deltaxp * deltaX + (Y - row / 2)**2 * deltayp * deltaY))
    T2 = np.pad(T2, pad)
    T2 = np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(T2 * FC)))

    # Tercer transformar
    K = np.fft.ifftshift(np.fft.ifft2(np.fft.fftshift(T2 * T1)))
    K = K[pad:(pad + row), pad:(pad + col)]

    return K



# Phase reconstruction in DLHM
# Carlos Trujillo, Apr 7, 2018.
# Modified by Jose Pamplona: MAY 21, 2022.


plt.rcParams["figure.figsize"] = (15,15)


# Recovery of sample info
# Sample info loading
filename = r'H05 (3).png'
holo = np.array(Image.open(filename))
#holo= cv2.resize(holo,(128,128),interpolation=cv2.INTER_LINEAR)
[fi, co,] = holo.shape
holo = holo[:, int((co-fi)/2):co-int((co-fi)/2)]
[fi, co] = holo.shape
# print(holo.shape)

# filename = r'/content/muestra1_1.bmp'
# ref = np.array(Image.open(filename))

# holoContrast = holo - ref     # Amplitude reconstructions
holoContrast = holo             # Phase reconstructions
#plt.imshow(holoContrast, cmap='gray')
#plt.show()

# Cosenus filter creation or reading
fold_files = listdir('.')
stored_filt = list(filter(lambda x: 'filtcos.npy' in x, fold_files))
# stripped = [s.strip('-filtcos.npy') for s in stored_filt]
if len(list(filter(lambda x: (str(co)+'-'+str(fi)) in x, fold_files))) == 0:
    fc = filtcosenoF(100, fi, co)
    np.save(str(co)+'-'+str(fi)+'_filtcos.npy', fc)
    print('Cosine filter saved')
else:
    fc = np.load(str(co)+'-'+str(fi)+'_filtcos.npy')
    print('Cosine filter loaded')
# plt.imshow(fc)
# Geometrical parameters
z = 5e-3
L = 8e-3
lamb = 532e-9
dx = 1.55e-6 #tamaño del pixel

# LET'S FIND THE BEST FOCUSED RECONSTRUCTION
# DLHM reconstruction
# pixel size at reconstruction plane
deltaX = z*dx/L  # in micrometers
pre_holo = prepairholoF_remap(holoContrast, dx, L) # Faster (0.11 Seconds)

# stack = []
for z in np.arange(3e-3, 4e-3,0.1e-3):
    # Reconstruct
    start = timer()
    reconstruction = kreuzer3F(pre_holo, z, L, lamb, deltaX, fc)
    end = timer()
    print(z*1000)
    print(timedelta(seconds=end - start))
    # Intensity and phase calculation
    # Am = np.abs(reconstruction)
    Ph = np.angle(reconstruction)
    In = (np.abs(reconstruction))**2
    plt.imshow(In,cmap='gray')
    plt.show()